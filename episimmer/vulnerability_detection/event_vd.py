from random import choice

from episimmer.policy.lockdown_policy import EventLockdown
from episimmer.read_file import (ReadAgents, ReadEvents, ReadLocations,
                                 ReadOneTimeEvents)
from episimmer.simulate import Simulate
from episimmer.utils.time import Time
from episimmer.vulnerability_detection.base import EventVulnerability


class SimpleEventVulnerability(EventVulnerability):
    def __init__(self, world_obj, parameter_dict):
        super().__init__()
        self.world_obj = world_obj
        self.states = parameter_dict['states']
        self.num_runs = parameter_dict['num_runs']
        self.event_identifier = parameter_dict['event_identifier']
        self.selected_event = None
        self.event_scores = {}
        self.event_counts = {}
        self.events = self.get_events()
        self.init_scores()

    def init_scores(self):
        for event in self.events:
            self.event_scores[event] = 0.0
            self.event_counts[event] = 0

    def get_events(self):
        agents_obj = ReadAgents(self.world_obj.agents_filename,
                                self.world_obj.config_obj)
        locations_obj = ReadLocations(self.world_obj.locations_filename,
                                      self.world_obj.config_obj)
        one_time_event_obj = ReadOneTimeEvents(
            self.world_obj.one_time_event_file)

        for event_files_list in self.world_obj.event_files_list:
            if event_files_list:
                for events_filename in event_files_list:
                    ReadEvents(events_filename, self.world_obj.config_obj,
                               locations_obj, agents_obj)

        for time_step in range(self.world_obj.config_obj.time_steps):
            one_time_event_obj.populate_one_time_events(
                self.world_obj.config_obj, locations_obj, agents_obj,
                time_step)
        events_id_list = set(event[self.event_identifier]
                             for location in locations_obj.locations.values()
                             for event in location.events)

        return list(events_id_list)

    def select_event(self):
        self.selected_event = choice(self.events)
        self.event_counts[self.selected_event] += 1
        events_to_remove = self.events.copy()
        events_to_remove.remove(self.selected_event)
        return [
            EventLockdown(self.event_identifier, events_to_remove,
                          lambda x: True)
        ]

    def update_event_scores(self, end_state):
        infected_agents = sum(end_state[state][-1] for state in self.states)
        total_agents = sum(end_state[state][-1] for state in end_state)
        event_score = infected_agents / total_agents
        self.event_scores[self.selected_event] += 1.0 / self.event_counts[
            self.selected_event] * (event_score -
                                    self.event_scores[self.selected_event])

    def one_run(self):
        Time.new_world()
        time_steps = self.world_obj.config_obj.time_steps
        agents_obj = ReadAgents(self.world_obj.agents_filename,
                                self.world_obj.config_obj)
        locations_obj = ReadLocations(self.world_obj.locations_filename,
                                      self.world_obj.config_obj)
        one_time_event_obj = ReadOneTimeEvents(
            self.world_obj.one_time_event_file)
        policy_list = self.select_event()

        sim_obj = Simulate(self.world_obj.config_obj, self.world_obj.model,
                           policy_list, agents_obj, locations_obj)
        sim_obj.on_start_simulation()

        for current_time_step in range(time_steps):
            sim_obj.on_start_time_step(
                self.world_obj.interaction_files_list,
                self.world_obj.event_files_list,
                self.world_obj.probabilistic_interaction_files_list,
                one_time_event_obj)
            sim_obj.handle_time_step_for_all_agents()
            sim_obj.end_time_step()
            Time.increment_current_time_step()

        end_state = sim_obj.end_simulation()
        self.update_event_scores(end_state)

    def run_detection(self):
        for i in range(self.num_runs):
            if (i + 1) % (self.num_runs / 10) == 0:
                print('Iteration running: ', i + 1)
            self.one_run()
