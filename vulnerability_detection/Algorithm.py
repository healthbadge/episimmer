import matplotlib.pyplot as plt
import random
import Simulate
import ReadFile
import sys
import numpy as np
import os
import Time
sys.path.insert(1, '../src/')


class Vulnerable_Agents():
    def __init__(self):
        self.type = "Vulnerable Agents"


class Agent_Vulnerabilities():
    def __init__(self):
        self.type = "Agent Vulnerabilities"

########################################################################
### Vulnerable Agents
########################################################################

class Vulnerable_Agent_MC1(Vulnerable_Agents):
    def __init__(self, world_obj, states):
        super().__init__()
        self.world_obj=world_obj
        self.states = states
        self.agent_scores={}
        self.init_scores()

    def init_scores(self):
        agents_obj=ReadFile.ReadAgents(self.world_obj.agents_filename,self.world_obj.config_obj)
        for agent_index in agents_obj.agents.keys():
            self.agent_scores[agent_index]=0

    def update_agent_scores(self,agents_obj):
        for agent in agents_obj.agents.values():
            for state in self.states:
                if agent.state==state:
                    self.agent_scores[agent.index]+=1
                    break

    def one_run(self):
        _,agents_obj,_=self.world_obj.one_world()
        self.update_agent_scores(agents_obj)

    def do_MC(self,num_runs):
        for i in range(num_runs):
            if i%(num_runs/10)==0:
                print(i)
            self.one_run()

    def get_maximum_vulnerable_agents(self,n):
        res_max = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[-n:])
        return res_max

    def get_minimum_vulnerable_agents(self,n):
        res_min = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[:n])
        return res_min


class Vulnerable_Agent_MC2(Vulnerable_Agents):
    def __init__(self, read_obj, begin_count_state):
        super().__init__()
        self.read_obj=read_obj
        self.begin_count_state = begin_count_state
        self.agent_scores={}
        self.agent_start_infection_step = {}
        self.init_scores()

    def init_scores(self):
        agents_obj=ReadFile.ReadAgents(self.read_obj.agents_filename,self.read_obj.config_obj)
        for agent_index in agents_obj.agents.keys():
            self.agent_scores[agent_index]=0

    def reset_start_infection(self,agents_obj):
        for agent_index in agents_obj.agents.keys():
            self.agent_start_infection_step[agent_index] = None


    def update_agent_scores(self,agents_obj):

        total_time_steps = self.read_obj.config_obj.time_steps
        for agent in agents_obj.agents.values():
            if(self.agent_start_infection_step[agent.index] is not None):
                self.agent_scores[agent.index] += total_time_steps - self.agent_start_infection_step[agent.index]


    def update_agent_start_infection(self,agents_obj,time_step):
        for agent in agents_obj.agents.values():
            if agent.state==self.begin_count_state and self.agent_start_infection_step[agent.index] is None:
                self.agent_start_infection_step[agent.index] = time_step


    def one_run(self):
        time_steps = self.read_obj.config_obj.time_steps

        Time.Time.new_world()

        # Initialize agents
        agents_obj = ReadFile.ReadAgents(self.read_obj.agents_filename, self.read_obj.config_obj)

        self.reset_start_infection(agents_obj)

        # Intialize locations
        locations_obj = ReadFile.ReadLocations(self.read_obj.locations_filename, self.read_obj.config_obj)

        # Initialize one time events
        oneTimeEvent_obj = ReadFile.ReadOneTimeEvents(self.read_obj.one_time_event_file)

        sim_obj = Simulate.Simulate(self.read_obj.config_obj, self.read_obj.model, self.read_obj.policy_list, self.read_obj.event_restriction_fn, agents_obj, locations_obj)
        sim_obj.onStartSimulation()

        for current_time_step in range(time_steps):
            sim_obj.onStartTimeStep(self.read_obj.interactions_files_list, self.read_obj.events_files_list, self.read_obj.probabilistic_interactions_files_list, oneTimeEvent_obj)
            sim_obj.handleTimeStepForAllAgents()
            sim_obj.endTimeStep()
            Time.Time.increment_current_time_step()
            self.update_agent_start_infection(agents_obj,current_time_step)

        end_state = sim_obj.endSimulation()
        self.update_agent_scores(agents_obj)

    def do_MC(self,num_runs):
        for i in range(num_runs):
            if i%(num_runs/10)==0:
                print(i)
            self.one_run()

    def get_maximum_vulnerable_agents(self,n):
        res_max = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[-n:])
        return res_max

    def get_minimum_vulnerable_agents(self,n):
        res_min = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[:n])
        return res_min

########################################################################
### Agent Vulnerabilities
########################################################################


class Agent_Vulnerabilities_MC(Agent_Vulnerabilities):
    def __init__(self, read_obj, states):
        super().__init__()
        self.read_obj=read_obj
        self.states = states
        self.agent_scores={}
        self.agents_to_remove = None
        self.agent_counts = {}
        self.agent_history = {}
        self.init_scores()

    def init_scores(self):
        agents_obj=ReadFile.ReadAgents(self.read_obj.agents_filename,self.read_obj.config_obj)
        for agent_index in agents_obj.agents.keys():
            self.agent_scores[agent_index] = 0.0
            self.agent_counts[agent_index] = 0
            self.agent_history[agent_index] = []

    def remove_agents(self,agents_obj,num_agents_to_remove):
        agents = list(agents_obj.agents)
        self.agents_to_remove = random.sample(agents, num_agents_to_remove)
        for agent in self.agents_to_remove:
            agents_obj.agents.pop(agent)
            self.agent_counts[agent] += 1

    def update_agent_scores(self,end_state):
        agent_score = 0
        for state in self.states:
            agent_score += end_state[state][-1]
        total_agents = 0
        for key in end_state:
            total_agents += end_state[key][-1]
        score = 1.0 - agent_score/total_agents
        for agent in self.agents_to_remove:
            # self.agent_scores[agent] += score
            self.agent_scores[agent] += 1.0 / (self.agent_counts[agent] + 1) * (score - self.agent_scores[agent])


    def one_run(self,num_agents_to_remove):
        time_steps = self.read_obj.config_obj.time_steps

        Time.Time.new_world()

        # Initialize agents
        agents_obj = ReadFile.ReadAgents(self.read_obj.agents_filename, self.read_obj.config_obj)

        if(num_agents_to_remove>0):
            self.remove_agents(agents_obj,num_agents_to_remove)

        # Intialize locations
        locations_obj = ReadFile.ReadLocations(self.read_obj.locations_filename, self.read_obj.config_obj)

        # Initialize one time events
        oneTimeEvent_obj = ReadFile.ReadOneTimeEvents(self.read_obj.one_time_event_file)

        sim_obj = Simulate.Simulate(self.read_obj.config_obj, self.read_obj.model, self.read_obj.policy_list, self.read_obj.event_restriction_fn, agents_obj, locations_obj)
        sim_obj.onStartSimulation()

        for current_time_step in range(time_steps):
            sim_obj.onStartTimeStep(self.read_obj.interactions_files_list, self.read_obj.events_files_list, self.read_obj.probabilistic_interactions_files_list, oneTimeEvent_obj)
            sim_obj.handleTimeStepForAllAgents()
            sim_obj.endTimeStep()
            Time.Time.increment_current_time_step()

        end_state = sim_obj.endSimulation()
        self.update_agent_scores(end_state)

    def do_MC(self,num_runs,num_agents_to_remove):
        for i in range(num_runs):
            if i!=0 and i%(num_runs/10)==0:
                print(i)
            self.one_run(num_agents_to_remove)

    def get_maximum_agent_vulnerability(self,n):
        res_max = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[-n:])
        return res_max

    def get_minimum_agent_vulnerability(self,n):
        res_min = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[:n])
        return res_min


class BanditAlgos(Agent_Vulnerabilities):
    def __init__(self, read_obj, states):
        super().__init__()
        self.read_obj = read_obj
        self.states = states
        self.agent_scores = {}
        self.agents_to_remove = None
        self.agent_counts = {}
        self.eps = 0.01
        self.rm_agent = None
        self.agent_history = {}
        self.init_scores()

    def init_scores(self):
        agents_obj = ReadFile.ReadAgents(
            self.read_obj.agents_filename, self.read_obj.config_obj)
        for agent_index in agents_obj.agents.keys():
            self.agent_scores[int(agent_index)] = 1.0
            # self.agent_scores[int(agent_index)] = self.get_init_score(agent_index)
            self.agent_counts[int(agent_index)] = 0
            self.agent_history[int(agent_index)] = []

    def get_init_score(self, agent_index):

        agents_obj = ReadFile.ReadAgents(self.read_obj.agents_filename, self.read_obj.config_obj)
        agents_obj.agents.pop(agent_index)
        end_state, _, _ = self.one_run_helper(agents_obj)
        return self.get_score(end_state)

    def remove_agents(self, agents_obj):

        agents = list(agents_obj.agents)
        """
        if random.random() < self.eps:
            self.rm_agent = random.randint(0, len(agents) - 1)
        else:
            self.rm_agent = max(range(len(agents)), key=lambda x: self.agent_scores[x])
        """
        self.rm_agent = max(range(len(agents)), key=lambda x: self.agent_scores[x] + np.sqrt(2 * np.log(self.t) / (1 + self.agent_counts[x])))
        agents_obj.agents.pop(str(self.rm_agent))
        self.agent_counts[self.rm_agent] += 1

    def get_score(self, end_state):
        agent_score = 0
        for state in self.states:
            agent_score += end_state[state][-1]
        total_agents = 0
        for key in end_state:
            total_agents += end_state[key][-1]
        score = 1.0 - agent_score/total_agents
        return score

    def update_agent_scores(self, end_state):
        score = self.get_score(end_state)
        self.agent_scores[self.rm_agent] += 1.0 / (self.agent_counts[self.rm_agent] + 1) * (score - self.agent_scores[self.rm_agent])

    def one_run_helper(self, agents_obj):

        time_steps = self.read_obj.config_obj.time_steps

        Time.Time.new_world()

        # Intialize locations
        locations_obj = ReadFile.ReadLocations(self.read_obj.locations_filename, self.read_obj.config_obj)

        # Initialize one time events
        oneTimeEvent_obj = ReadFile.ReadOneTimeEvents(self.read_obj.one_time_event_file)

        sim_obj = Simulate.Simulate(self.read_obj.config_obj, self.read_obj.model, self.read_obj.policy_list, self.read_obj.event_restriction_fn, agents_obj, locations_obj)
        sim_obj.onStartSimulation()

        for current_time_step in range(time_steps):
            sim_obj.onStartTimeStep(self.read_obj.interactions_files_list, self.read_obj.events_files_list, self.read_obj.probabilistic_interactions_files_list, oneTimeEvent_obj)
            sim_obj.handleTimeStepForAllAgents()
            sim_obj.endTimeStep()
            Time.Time.increment_current_time_step()

        end_state = sim_obj.endSimulation()
        return end_state, agents_obj, locations_obj

    def one_run(self):

        agents_obj = ReadFile.ReadAgents(self.read_obj.agents_filename, self.read_obj.config_obj)
        self.remove_agents(agents_obj)
        end_state, _, _ = self.one_run_helper(agents_obj)
        self.update_agent_scores(end_state)

    def do_MC(self, num_runs):
        for i in range(num_runs):
            if i!=0 and i % (num_runs/10) == 0:
                print(i)
            self.t = i + 1
            self.one_run()

    def get_maximum_agent_vulnerability(self, n):
        res_max = dict(sorted(self.agent_scores.items(),
                       key=lambda x: (x[1], x[0]))[-n:])
        return res_max

    def get_minimum_agent_vulnerability(self, n):
        res_min = dict(sorted(self.agent_scores.items(),
                       key=lambda x: (x[1], x[0]))[:n])
        return res_min


class Agent_Vulnerabilities_MC3(Agent_Vulnerabilities):
    def __init__(self, read_obj, states, chunk_len_range = [1,50]):
        super().__init__()
        self.read_obj=read_obj
        self.states = states
        self.agent_scores={}
        self.agents_to_remove = None

        self.time_steps = self.read_obj.config_obj.time_steps
        self.start_agent_score = None
        self.end_agent_score = None
        self.range_list = list(range(chunk_len_range[0],chunk_len_range[1]+1))
        self.init_scores()

    def init_scores(self):
        agents_obj=ReadFile.ReadAgents(self.read_obj.agents_filename,self.read_obj.config_obj)
        for agent_index in agents_obj.agents.keys():
            self.agent_scores[agent_index]=0

    def remove_agents(self,agents_obj,num_agents_to_remove):
        agents = list(agents_obj.agents)
        self.agents_to_remove = random.sample(agents, num_agents_to_remove)
        for agent in self.agents_to_remove:
            agents_obj.agents.pop(agent)

    def reset_world(self,agents_obj):
        self.start_agent_score = None
        self.end_agent_score = None

    def get_scores(self, agents_obj):
        score=0
        for agent in agents_obj.agents.values():
            for state in self.states:
                if agent.state==state:
                    score+=1
                    break
        return score


    def update_agent_scores(self,agents_obj, time_step, mode):
        if(mode=='start'):
            self.start_agent_score = self.get_scores(agents_obj)
        elif(mode=='end'):
            self.end_agent_score = self.get_scores(agents_obj)
            for agent in self.agents_to_remove:
                self.agent_scores[agent]+=self.end_agent_score - self.start_agent_score

    def one_run(self,num_agents_to_remove, start, end):

        Time.Time.new_world()

        # Initialize agents
        agents_obj = ReadFile.ReadAgents(self.read_obj.agents_filename, self.read_obj.config_obj)

        self.reset_world(agents_obj)
        if(num_agents_to_remove>0):
            self.remove_agents(agents_obj,num_agents_to_remove)

        # Intialize locations
        locations_obj = ReadFile.ReadLocations(self.read_obj.locations_filename, self.read_obj.config_obj)

        # Initialize one time events
        oneTimeEvent_obj = ReadFile.ReadOneTimeEvents(self.read_obj.one_time_event_file)

        sim_obj = Simulate.Simulate(self.read_obj.config_obj, self.read_obj.model, self.read_obj.policy_list, self.read_obj.event_restriction_fn, agents_obj, locations_obj)
        sim_obj.onStartSimulation()
        flag =0
        for current_time_step in range(self.time_steps):
            sim_obj.onStartTimeStep(self.read_obj.interactions_files_list, self.read_obj.events_files_list, self.read_obj.probabilistic_interactions_files_list, oneTimeEvent_obj)
            sim_obj.handleTimeStepForAllAgents()
            sim_obj.endTimeStep()
            Time.Time.increment_current_time_step()
            if(current_time_step==start):
                self.update_agent_scores(agents_obj, current_time_step, 'start')
                flag+=1
            if(current_time_step==end):
                self.update_agent_scores(agents_obj, current_time_step, 'end')
                flag+=1
                break

        end_state=sim_obj.endSimulation()
        assert flag==2

    def generate_bounds(self):
        chunk_len = random.choice(self.range_list)

        if(chunk_len<=0):
            return None, None
        if(chunk_len>=self.time_steps):
            return 0,self.time_steps-1

        start_list = list(range(self.time_steps-chunk_len+1))
        start = random.choice(start_list)
        end = start+chunk_len-1
        return start,end

    def do_MC(self,num_runs,num_agents_to_remove):
        for i in range(num_runs):
            if i%(num_runs/10)==0:
                print(i)
            start, end = self.generate_bounds()
            if start is None:
                continue
            self.one_run(num_agents_to_remove, start, end)

    def get_maximum_agent_vulnerability(self,n):
        res_max = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[:n])
        return res_max

    def get_minimum_agent_vulnerability(self,n):
        res_min = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[-n:])
        return res_min
